# gofr-doc Production Dockerfile
# Lightweight image for MCP, MCPO, and Web servers.
# Each server runs as a separate compose service â€” no supervisor needed.
FROM python:3.11-slim

# Install system dependencies and WeasyPrint native libraries
RUN apt-get update && apt-get install -y --no-install-recommends \
    curl \
    libpango-1.0-0 \
    libpangoft2-1.0-0 \
    libpangocairo-1.0-0 \
    libgdk-pixbuf-2.0-0 \
    libffi-dev \
    libcairo2 \
    libglib2.0-0 \
    && rm -rf /var/lib/apt/lists/*

# Install uv for fast Python package management
RUN pip install --no-cache-dir uv

# Create gofr-doc user and group with standard GOFR UID/GID (1000:1000)
# All GOFR containers use UID 1000 / GID 1000 regardless of username,
# so shared Docker volumes (gofr-secrets, etc.) just work without chown.
ARG GOFR_UID=1000
ARG GOFR_GID=1000
RUN groupadd --gid ${GOFR_GID} gofr-doc && \
    useradd --uid ${GOFR_UID} --gid gofr-doc --home-dir /home/gofr-doc --create-home gofr-doc

# Create application directories
RUN mkdir -p /home/gofr-doc/app \
    && mkdir -p /home/gofr-doc/data/storage \
    && mkdir -p /home/gofr-doc/data/auth \
    && mkdir -p /home/gofr-doc/data/templates \
    && mkdir -p /home/gofr-doc/data/fragments \
    && mkdir -p /home/gofr-doc/data/styles \
    && mkdir -p /home/gofr-doc/logs \
    && chown -R gofr-doc:gofr-doc /home/gofr-doc

WORKDIR /home/gofr-doc

# ---- Dependency layer (cached unless pyproject.toml or lib/ change) ----
COPY --chown=gofr-doc:gofr-doc pyproject.toml /home/gofr-doc/
COPY --chown=gofr-doc:gofr-doc README.md /home/gofr-doc/
COPY --chown=gofr-doc:gofr-doc lib/ /home/gofr-doc/lib/

# Create venv and install dependencies (cached until pyproject.toml/lib change)
RUN uv venv /home/gofr-doc/.venv --python=python3.11

ENV VIRTUAL_ENV=/home/gofr-doc/.venv
ENV PATH="/home/gofr-doc/.venv/bin:$PATH"

# Install gofr-common from lib/, then the main project
RUN uv pip install -e ./lib/gofr-common && uv pip install -e .

# Install mcpo for OpenAPI proxy
RUN uv pip install mcpo

# ---- Application code (rebuilds only when app/ changes) ----
COPY --chown=gofr-doc:gofr-doc app/ /home/gofr-doc/app/

# Stage built-in content outside the data volume mount point.
# The entrypoint deploys these into the data volume at container start.
#
# INTERIM: Baking content into the app image is expedient but does not scale.
# As templates, fragments, and images grow, move to a dedicated content-init
# container (like vault-init) that populates the data volume independently,
# keeping the app image lean. See also: entrypoint-prod.sh.
COPY --chown=gofr-doc:gofr-doc app/content/templates/ /home/gofr-doc/_content/templates/
COPY --chown=gofr-doc:gofr-doc app/content/styles/    /home/gofr-doc/_content/styles/
COPY --chown=gofr-doc:gofr-doc app/content/fragments/ /home/gofr-doc/_content/fragments/
COPY --chown=gofr-doc:gofr-doc app/content/images/    /home/gofr-doc/_content/images/

# Fix ownership after installation
RUN chown -R gofr-doc:gofr-doc /home/gofr-doc

# Vault AppRole credentials are now provided at runtime via the gofr-secrets
# Docker volume mounted at /run/secrets (see compose.prod.yml).
# We only create the directory here so the mount point exists.
RUN mkdir -p /run/secrets && chown gofr-doc:gofr-doc /run/secrets

# Copy production entrypoint (handles Vault JWT read, creds copy, user drop)
COPY --chown=root:root docker/entrypoint-prod.sh /home/gofr-doc/entrypoint-prod.sh
RUN chmod +x /home/gofr-doc/entrypoint-prod.sh

# Ports are configured at runtime via compose.yml + gofr_ports.env.
# EXPOSE uses build ARGs so `docker inspect` reflects the correct ports.
ARG GOFR_DOC_MCP_PORT
ARG GOFR_DOC_MCPO_PORT
ARG GOFR_DOC_WEB_PORT
EXPOSE ${GOFR_DOC_MCP_PORT:-0} ${GOFR_DOC_MCPO_PORT:-0} ${GOFR_DOC_WEB_PORT:-0}

# Default: run as gofr-doc user
# compose.prod.yml overrides entrypoint per service
USER gofr-doc